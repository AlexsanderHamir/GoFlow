// Package simulator provides a concurrent pipeline simulator for testing and benchmarking
// multi-stage data processing workflows. It supports both continuous and burst-based
// data generation, configurable processing stages, and comprehensive metrics collection.
//
// The simulator is designed to help developers understand how their pipeline stages
// perform under various load conditions, including:
//   - Different input rates and burst patterns
//   - Backpressure handling and drop policies
//   - Worker concurrency and processing delays
//   - Error handling and retry mechanisms
//
// # Key Features
//
//   - **Concurrent Processing**: Each stage can run multiple worker goroutines
//   - **Flexible Generation**: Support for both rate-limited and burst-based data generation
//   - **Backpressure Handling**: Configurable drop policies when channels are full
//   - **Comprehensive Metrics**: Real-time collection of throughput, drop rates, and processing stats
//   - **Graceful Shutdown**: Proper cleanup and termination of all goroutines
//   - **Retry Logic**: Configurable retry mechanisms for failed processing
//
// # Usage Example
//
//	sim := simulator.NewSimulator()
//	sim.Duration = 10 * time.Second
//
//	// Create a generator stage
//	generatorConfig := &simulator.StageConfig{
//		IsGenerator:    true,
//		ItemGenerator:  func() any { return "data" },
//		InputRate:      100 * time.Millisecond,
//		RoutineNum:     1,
//		BufferSize:     100,
//	}
//	generator := simulator.NewStage("generator", generatorConfig)
//
//	// Create a processing stage
//	processorConfig := &simulator.StageConfig{
//		WorkerFunc:     func(item any) (any, error) { return item, nil },
//		RoutineNum:     3,
//		BufferSize:     50,
//		WorkerDelay:    50 * time.Millisecond,
//		RetryCount:     2,
//	}
//	processor := simulator.NewStage("processor", processorConfig)
//
//	sim.AddStage(generator)
//	sim.AddStage(processor)
//	sim.Start()
//
// # Architecture
//
// The simulator uses a pipeline architecture where data flows through stages:
// Generator → Stage1 → Stage2 → ... → FinalStage
//
// Each stage runs in its own goroutine(s) and communicates via buffered channels.
// The first stage is always a generator that produces data, while subsequent stages
// process and transform the data. The final stage typically discards results.
//
// # Thread Safety
//
// The simulator is designed to be thread-safe and can be safely used from multiple
// goroutines. All internal state is protected by appropriate synchronization primitives.
package simulator

import (
	"context"
	"fmt"
	"sync"
	"time"
)

// Simulator represents a concurrent pipeline simulator that orchestrates
// multiple processing stages in a data flow pipeline.
//
// The simulator manages the lifecycle of all stages, coordinates data flow
// between them, and collects comprehensive performance metrics. It supports
// both time-based and item-count-based termination conditions.
type Simulator struct {
	// Duration specifies how long the simulation should run.
	// If set to a positive value, the simulation will automatically stop
	// after this duration. Mutually exclusive with MaxGeneratedItems.
	Duration time.Duration

	// MaxGeneratedItems is the maximum number of items to generate before stopping.
	// If set to a positive value, the simulation will stop once this many items
	// have been generated by the first stage. Mutually exclusive with Duration.
	MaxGeneratedItems int

	// Stages contains all the processing stages in the pipeline, ordered
	// from first (generator) to last (final stage).
	Stages []*Stage

	// Mu protects access to the Stages slice and other shared state
	Mu sync.RWMutex

	// Ctx provides cancellation context for all stages
	Ctx context.Context

	// Cancel function to stop all stages gracefully
	Cancel context.CancelFunc

	// Quit channel is closed when the simulation completes
	Quit chan struct{}

	// Wg tracks all running goroutines for proper cleanup
	Wg sync.WaitGroup
}

// NewSimulator creates a new simulator instance with proper initialization.
//
// Returns a simulator with:
//   - A cancellable context for graceful shutdown
//   - A quit channel for completion signaling
//   - Proper synchronization primitives
//
// The simulator is ready to have stages added and configured.
func NewSimulator() *Simulator {
	ctx, cancel := context.WithCancel(context.Background())
	return &Simulator{
		Ctx:    ctx,
		Cancel: cancel,
		Quit:   make(chan struct{}),
	}
}

// AddStage adds a new stage to the pipeline with validation.
//
// The stage is added to the end of the pipeline. The first stage added
// should be a generator (IsGenerator: true), while subsequent stages
// should be processors (IsGenerator: false).
//
// Args:
//   - stage: The stage to add to the pipeline
//
// Returns:
//   - error: nil if successful, or an error describing the validation failure
//
// Validation rules:
//   - Stage cannot be nil
//   - Stage name cannot be empty
//   - Stage name must be unique within the pipeline
func (s *Simulator) AddStage(stage *Stage) error {
	s.Mu.Lock()
	defer s.Mu.Unlock()

	if stage == nil {
		return fmt.Errorf("stage cannot be nil")
	}

	if stage.Name == "" {
		return fmt.Errorf("stage name cannot be empty")
	}

	for _, existingStage := range s.Stages {
		if existingStage.Name == stage.Name {
			return fmt.Errorf("stage with name %s already exists", stage.Name)
		}
	}

	s.Stages = append(s.Stages, stage)
	return nil
}

// Start begins the simulation and blocks until completion.
//
// This method initializes all stages, starts their goroutines, and waits
// for the simulation to complete based on the configured termination
// condition (Duration or MaxGeneratedItems).
//
// The simulation will automatically stop when:
//   - The configured Duration has elapsed (if Duration > 0)
//   - The configured MaxGeneratedItems have been generated (if MaxGeneratedItems > 0)
//   - Stop() is called explicitly
//
// Returns:
//   - error: nil if successful, or an error describing the failure
//
// Panics:
//   - If both Duration and MaxGeneratedItems are set to positive values
func (s *Simulator) Start() error {
	s.Mu.RLock()
	defer s.Mu.RUnlock()

	if len(s.Stages) == 0 {
		return fmt.Errorf("no stages to run")
	}

	if err := s.initializeStages(); err != nil {
		return fmt.Errorf("failed to initialize stages: %w", err)
	}

	go func() {
		if s.MaxGeneratedItems > 0 && s.Duration > 0 {
			panic("either duration or max generated items must be set, not both")
		}

		durationActive := s.MaxGeneratedItems <= 0 && s.Duration > 0
		if durationActive {
			time.Sleep(s.Duration)
			s.Stop()
		}

		s.Wg.Wait()
		close(s.Quit)
	}()

	s.WaitForStats()

	return nil
}

// Stop gracefully terminates the simulation by canceling the context.
//
// This method signals all stages to stop processing and initiates
// a graceful shutdown. All goroutines will receive the cancellation
// signal and clean up their resources.
func (s *Simulator) Stop() {
	s.Cancel()
}

// Done returns a channel that is closed when the simulation completes.
//
// This channel can be used to wait for simulation completion without
// blocking the calling goroutine. Useful for implementing custom
// completion handling or integration with other systems.
//
// Returns:
//   - <-chan struct{}: A channel that closes when simulation is done
func (s *Simulator) Done() <-chan struct{} {
	return s.Quit
}

// WaitForStats blocks until the simulation completes and then prints statistics.
//
// This is a convenience method that combines waiting for completion
// with automatic statistics reporting. Equivalent to calling
// <-s.Done() followed by s.PrintStats().
func (s *Simulator) WaitForStats() {
	<-s.Done()
	s.PrintStats()
}

// GetStages returns a copy of all stages in the pipeline.
//
// This method provides thread-safe access to the stages slice.
// The returned slice is a copy, so modifications won't affect
// the running simulation.
//
// Returns:
//   - []*Stage: A copy of all stages in the pipeline
func (s *Simulator) GetStages() []*Stage {
	s.Mu.RLock()
	defer s.Mu.RUnlock()

	return s.Stages
}

// PrintStats displays comprehensive statistics for all stages in the pipeline.
//
// The statistics include:
//   - Processed items count
//   - Output items count
//   - Throughput (items per second)
//   - Dropped items count
//   - Drop rate percentage
//   - Generated items (for generator stages)
//   - Percentage changes between stages
//
// The output is formatted as a table for easy reading and analysis.
func (s *Simulator) PrintStats() {
	stages := s.GetStages()
	printHeader()

	var prev *StageStats
	for _, stage := range stages {
		current := collectStageStats(stage)
		procDiff, thruDiff := computeDiffs(prev, &current)
		printStageRow(&current, procDiff, thruDiff)
		prev = &current
	}

	fmt.Println()
}
